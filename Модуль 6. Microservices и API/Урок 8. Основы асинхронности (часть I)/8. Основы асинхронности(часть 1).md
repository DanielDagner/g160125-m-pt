# Асинхронность в Python: конспект лекции

## 1. Введение в асинхронность

**Что такое асинхронность:** Асинхронное программирование – это способ выполнять несколько задач «одновременно» без создания нескольких потоков или процессов. В традиционном синхронном коде каждая операция выполняется последовательно: следующая начинается только после завершения предыдущей. Если одна из задач вынуждена ждать (например, ответа от сервера или чтения файла), то вся программа простаивает в ожидании. Асинхронность решает эту проблему: пока одна задача ждет результата ввода-вывода (IO), другая задача может выполняться. Это повышает эффективность программы, особенно при большом количестве операций ввода-вывода.

**Почему это важно:** Представьте, что ваша программа должна обработать сотни запросов к веб-серверу или выполнить множество операций чтения/записи файлов. Синхронный подход заставит выполнять их по очереди, что может занять много времени, в то время как асинхронный подход позволит запускать их конкурентно (параллельно **по времени**). Это значит, что программа не будет бездействовать впустую в ожидании, а сможет делать другую полезную работу. В результате приложения на основе асинхронности способны обслуживать больше запросов и реагировать быстрее, не увеличивая при этом количество потоков или процессов.

**Отличие от многопоточности и многозадачности:** Важно понимать разницу между асинхронностью и другими формами конкурентности:

- *Многопоточность* – выполнение нескольких потоков внутри одного процесса. Потоки могут выполняться параллельно на разных ядрах (но в Python есть ограничение GIL, из-за которого истинный параллелизм для CPU-связанных задач затруднён). Потоки переключаются операционной системой, и разработчику приходится заботиться о блокировках, разделяемых ресурсах и возможных гонках данных.
- *Многозадачность* (в контексте ОС или многопроцессности) – выполнение нескольких процессов параллельно. Каждый процесс имеет свою память. Это позволяет использовать несколько ядер CPU без ограничений GIL, но создание процессов более “тяжёлое” (каждый процесс – отдельная программа с собственной памятью).
- *Асинхронность (AsyncIO)* – предоставляет *кооперативную* многозадачность в рамках одного потока. Это значит, что задачи (корутины) сами уступают управление, когда им нечего делать (например, ждут ответа). Управляет этим специальный цикл событий (event loop). В отличие от потоков, переключение между асинхронными задачами происходит **только в точках ожидания (await)**. Нет необходимости в блокировках, так как в один момент времени код реально выполняется только из одной задачи. Асинхронность идеальна для задач ввода-вывода (сетевые запросы, работа с файловой системой, ожидание таймеров), но не ускоряет CPU-емкие вычисления (поскольку они всё равно выполняются по очереди в одном потоке).

**Простая аналогия (рестораны):**  
- *Синхронно* – Представьте ресторан с одним поваром. Он готовит заказы по одному: сначала приготовит блюдо для первого клиента, **полностью завершит** его, затем перейдёт к блюду для второго, и т.д. Если приготовление блюда требует времени (например, запекание в духовке на 30 минут), повар всё это время больше ничем не занят, просто ждёт.  
- *Многопоточность* – Добавим ещё поваров (несколько потоков). Каждый повар может параллельно готовить своё блюдо. Например, один готовит яичницу, другой жарит гренки одновременно. Это быстрее, но может возникнуть конфликт за ресурсы (общая плита, сковорода, внимание официанта и т.д.), и нужна координация.  
- *Асинхронность* – Опять один повар, но очень организованный. Он поставил яичницу на плиту и гренки в тостер, завёл таймеры и... вместо того чтобы просто ждать готовности, **занялся другими делами** – начал резать салат или убирать кухню. Как только таймер прозвенел (блюдо готово), он возвращается к этому блюду. Таким образом, пока блюда доходят, повар не простаивает. В коде роль таких “таймеров” и сигналов готовности выполняют `await` и событийный цикл, который сообщает, когда операция завершилась.

Эта аналогия показывает, как **асинхронность позволяет эффективно использовать время ожидания**: одна задача может быть “на паузе”, а процессор в это время занимается другой задачей.

## 2. Корутины и `await`

**Что такое корутина:** Корутина – это особая функция, которая может приостанавливать своё выполнение и возобновлять его позже. В Python корутины определяются ключевым словом `async def`. Вызов такой функции не выполняет её сразу, а возвращает объект-корутину. Этот объект можно представить как “незавершённую задачу”, которую нужно явно запустить и дождаться её результата. Дождаться выполнения корутины позволяет оператор `await`. 

Проще говоря, корутина – это функция, которая **работает в связке с циклом событий**. Она сообщает циклу: "Я сейчас жду, можешь пока переключиться на что-то другое." Обычная функция не умеет так делать – она либо выполняется до конца, либо блокирует поток, если ждёт какой-то ресурс.

**Как работают `async`/`await`:** Ключевое слово `async` перед `def` делает функцию асинхронной (корутиной). Внутри неё можно использовать `await` для операций, которые возвращают *awaitable*-объект (ещё одну корутину, задачу или Future). Когда корутина доходит до `await`, она **приостанавливается**, отдавая управление циклу событий, который может переключиться на выполнение других задач. Как только выполнение ожидаемой операции завершено, цикл возвращается к прерванной корутине и продолжает её работу после места `await`. 

**Аналогия с кафе и официантом:** Официант принимает заказ у клиента и относит его на кухню. Если работать синхронно, официант будет стоять на кухне и ждать, пока повар приготовит блюдо, затем отнесёт его клиенту и только потом примет заказ у следующего. В асинхронном подходе официант, отнеся заказ на кухню, **не ждёт на месте** – он сразу идёт к следующему столу принять новый заказ, затем к следующему, и так далее. Когда заказ готов, повар зовёт официанта (событие завершения), и тот забирает блюдо, относя его нужному клиенту. Здесь роль *await* выполняет момент отдачи заказа на кухню и соглашение “позови меня, когда будет готово”. Официант (корутина) при этом свободен обслуживать других – аналогично тому, как `await` освобождает цикл событий для выполнения других корутин.

**Отличие корутины от обычной функции:** Обычная функция запускается и выполняется последовательно, пока не вернёт результат (или не выбросит исключение). Она **не отдаёт управление** раньше времени. Корутина же при вызове не выполняется сразу и может многократно приостанавливаться. Например, при вызове корутины `fetch_data()` мы получаем объект, и только сделав `await fetch_data()`, действительно запустим её и дождёмся результата. Если внутри `fetch_data` есть паузы `await`, она может временно вернуть управление наружу (в цикл событий) прежде, чем полностью завершится. Поэтому, если попробовать вызвать корутину как обычную функцию без `await`, она не выполнит свой код, а просто вернёт объект корутины. Для новичков можно представить, что корутина – это как “ленивая” функция: она начинает работать только когда её явно попросят (await), и она может делать перерывы в работе.

Пример простой корутины с использованием `await` (имитируем задержку через `asyncio.sleep`): 

```python
import asyncio

async def say_hello():
    print("Привет...")
    await asyncio.sleep(1)  # пауза на 1 секунду (асинхронно)
    print("...мир!")

# Запуск корутины:
async def main():
    await say_hello()  # без await ничего не выполнится

asyncio.run(main())
```

Когда эта программа запускается, она сразу печатает "Привет...", затем **не блокируя поток** ждет 1 секунду (в это время можно было бы выполнять другие задачи), и потом печатает "...мир!". Если бы мы реализовали то же самое без `async/await`, используя, например, `time.sleep(1)`, то поток бы заснул на 1 секунду и ничего больше в это время сделать бы не смог.

## 3. Синхронный vs. асинхронный код

Разницу между синхронным и асинхронным кодом лучше всего проиллюстрировать на примере. Рассмотрим два сценария: один – с обычными функциями и последовательным выполнением, другой – с использованием `asyncio` для конкурентного выполнения. В файлах `Part01/simple_sync.py` и `Part01/simple_async.py` показаны соответствующие примеры.

**Синхронный пример (simple_sync.py):**  
```python
import time

def sync_task(name):
    print(f"{name} started")
    time.sleep(1)            # имитация длительной операции (блокирующий сон 1 секунду)
    print(f"{name} finished")

start_time = time.time()

sync_task("Task 1")
sync_task("Task 2")
sync_task("Task 3")

print(f"Total execution time: {time.time() - start_time:.2f} seconds")
```

- Здесь определена функция `sync_task`, которая печатает начало работы, затем задерживается на 1 секунду (например, имитируя операцию ввода-вывода), и печатает, что закончила работу. 
- В основном блоке мы последовательно вызываем `sync_task` три раза: сначала "Task 1", потом "Task 2", потом "Task 3". Каждая задача начнется только после завершения предыдущей.
- Время выполнения замеряется: суммарно будет примерно 3 секунды, потому что задачи идут одна за другой (1с + 1с + 1с).

**Вывод синхронной программы (приблизительно):**
```
Task 1 started  
Task 1 finished  
Task 2 started  
Task 2 finished  
Task 3 started  
Task 3 finished  
Total execution time: 3.00 seconds
```
Заметьте, пока выполнялась `Task 1` (спала 1 секунду), другие задачи просто ждали своей очереди.

**Асинхронный пример (simple_async.py):**  
```python
import asyncio, time

async def async_task(name, delay):
    print(f"{name} started")
    await asyncio.sleep(delay)   # асинхронная задержка на delay секунд
    print(f"{name} finished")
    return name  # вернем имя задачи по завершении (для примера)

async def main():
    start_time = time.time()
    # запускаем три задачи параллельно и ждем их завершения
    results = await asyncio.gather(
        async_task("Task 1", 1),
        async_task("Task 2", 1),
        async_task("Task 3", 1)
    )
    print(f"Total execution time: {time.time() - start_time:.2f} seconds")
    print("Results:", results)

asyncio.run(main())
```

- Здесь `async_task` – корутина, аналогичная `sync_task`, но вместо блокирующего `time.sleep` она использует `await asyncio.sleep()`. Это **не блокирует поток**, а приостанавливает `async_task`, позволяя другим задачам выполняться.
- В `main()` мы одновременно запускаем три задачи с помощью `asyncio.gather`. Функция `asyncio.gather` получает список awaitable-объектов (в данном случае вызовы корутин) и возвращает также awaitable, который завершится, когда **все** корутины в списке завершатся. Оператор `await` перед gather приостанавливает `main()` до тех пор, пока все три задачи не окончат работу.
- Несмотря на то, что каждая задача тоже "спит" 1 секунду, они делают это параллельно (конкурентно). Поэтому общее время выполнения должно получиться около 1 секунды, а не 3.
- Мы также собираем результаты задач: переменная `results` получит список значений, которые вернули корутины `async_task` (в данном случае мы вернули просто имя задачи).

**Вывод асинхронной программы (приблизительно):**
```
Task 1 started  
Task 2 started  
Task 3 started  
Task 1 finished  
Task 2 finished  
Task 3 finished  
Total execution time: 1.01 seconds  
Results: ['Task 1', 'Task 2', 'Task 3']
```
Обратите внимание: все три задачи начали выполняться почти одновременно, не дожидаясь друг друга. Через секунду (примерно) все три завершились почти вместе. Total execution time около 1 с, что существенно быстрее последовательных 3 секунд в синхронной версии.

**Аналогия с очередью в магазине (синхронно vs асинхронно):**  
- *Синхронный сценарий:* Представьте одну кассу в супермаркете и длинную очередь. Кассир обслуживает покупателей **строго по одному**. Пока один покупатель пробивает товары и оплачивает, следующий ждет. Если у первого покупателя какая-то заминка (например, он долго ищет кошелек или ждёт одобрения банковского платежа), кассир и все остальные стоят и ждут, потеря времени нарастает.
- *Асинхронный сценарий:* Теперь представьте, что кассир научился работать асинхронно. Он начинает обслуживать первого, сканирует товары, запускает процесс оплаты **и пока платеж обрабатывается**, сразу переключается к сканированию товаров следующего покупателя. Когда оплата первого подтверждена, кассир моментально возвращается к первому (к этому времени второй может уже ждать подтверждения своего платежа) и завершает его обслуживание. Затем продолжает со вторым, третьим и т.д. В результате никто не простаивает: пока один процесс (оплата) ожидает завершения, кассир занят другим делом (сканирует товары другого). Итог – очередь движется быстрее, хотя кассир все так же один. В компьютере роль такого "умного кассира" выполняет **асинхронный цикл событий**, а процессы, которые могут вызвать ожидание (оплата, запрос к серверу, чтение файла) реализуются через `await`.  

Важно подчеркнуть: асинхронность не делает вычисления мгновенными – каждый конкретный запрос как ждал, так и будет ждать своё время (первый покупатель всё равно тратит, скажем, 5 секунд на оплату). Но за эти 5 секунд успеют продвинуться дела и по другим запросам. Это и даёт выигрыш в производительности при множестве операций ввода-вывода.

## 4. `asyncio.gather` и `asyncio.create_task`

Когда начинаете работать с библиотекой `asyncio`, часто возникают вопросы: как запустить несколько корутин одновременно? Нужно ли использовать `asyncio.gather`, или `asyncio.create_task`, и в чем между ними разница?

**`asyncio.gather`:** Это высокоуровневая утилита, которая позволяет запускать несколько awaitable-объектов параллельно и ждать их завершения как единого целого. Вы передаете в `asyncio.gather` одну или несколько корутин (или задач), и он возвращает корутину, которая завершается, когда **все** переданные завершатся. Результат `gather` – список результатов в том же порядке, в каком были переданы задачи. Если любая из задач внутри `gather` завершится с исключением, `gather` пробросит это исключение (по умолчанию отменяя остальные задачи). `gather` удобно использовать, когда вам нужно запустить набор независимых операций и потом собрать все результаты разом.

Пример использования `asyncio.gather` (псевдокод):
```python
# Предположим, у нас есть три корутины, которые возвращают результат
result1, result2, result3 = await asyncio.gather(coro1(), coro2(), coro3())
print(result1, result2, result3)
```
Здесь `coro1()`, `coro2()`, `coro3()` запустятся одновременно, и `await` будет ждать, пока все они не закончатся. После этого мы получим три результата и можем их использовать.

**`asyncio.create_task`:** Это более низкоуровневая функция. Она принимает корутину и **запускает её как задачу (Task)** на фоне. Функция возвращает объект `asyncio.Task`, который представляет выполняющуюся задачу. Главное отличие в том, что `create_task` **не ждёт** окончания корутины сразу – он лишь планирует её выполнение. Вы можете сохранить объект задачи и продолжить выполнять другой код параллельно, а результат задачи получить позже, когда она завершится (например, с помощью `await task` или другими способами).

Пример использования `asyncio.create_task`:
```python
task = asyncio.create_task(some_coroutine())
# На этом месте some_coroutine уже начала выполняться в фоне.
# Можно выполнить какую-то другую работу параллельно.
# ...
result = await task  # ожидаем завершения задачи и получаем результат
```
Здесь задача запускается, и сразу после `create_task` управление возвращается нам – корутина `some_coroutine` выполняется "на фоне". Мы могли бы запустить несколько таких задач:
```python
task_a = asyncio.create_task(coro1())
task_b = asyncio.create_task(coro2())
# обе задачи работают параллельно сейчас
# можно сделать еще что-то или сразу ждать результатов:
res_a = await task_a
res_b = await task_b
```
Этот код логически похож на использование `gather`: две корутины выполняются одновременно, и потом мы ждём их результаты. Однако разница в том, что с `create_task` мы получаем явные объекты задач, которыми можно управлять (например, отменять).

**Когда что использовать:**
- Используйте `asyncio.gather`, когда вам нужно **одним вызовом запустить и дождаться** группу корутин, и вы заинтересованы в их результатах, получив их все сразу. Это удобнее и чище, когда задачи логически связаны, и вы хотите обработать все результаты вместе. В примере `Part01/simple_async.py` мы как раз использовали `await asyncio.gather(task1(), task2(), task3())` чтобы параллельно запустить три задачи и дождаться всех разом.
- Используйте `asyncio.create_task`, когда вам нужно запустить задачу, но *не* ждать её окончания немедленно – например, чтобы она выполнялась в фоновом режиме, пока ваш код делает что-то ещё. Также `create_task` полезен, когда вы хотите сохранить ссылку на задачу, чтобы, например, проверить её статус или отменить при необходимости (что с `gather` напрямую сделать сложнее, потому что он сам управляет задачами внутри). В `Part02/create_task_01.py` и `Part02/create_task_02.py` (судя по названию) показываются примеры создания задач с помощью `create_task` и отличия в поведении:
    - Возможно, `create_task_01.py` демонстрирует простой запуск задач и ожидание их завершения.
    - А `create_task_02.py` может показывать сценарий, где после создания задач выполняется какая-то дополнительная логика, прежде чем ждать результаты.

**Важно:** Внутри `asyncio.gather` переданные корутины *под капотом* тоже превращаются в задачи. То есть `gather` сам вызывает нечто похожее на `create_task` для каждой корутины, а затем ждёт их. Поэтому нет смысла оборачивать корутину в `create_task` перед передачей в `gather` – это избыточно. Например, `asyncio.gather(asyncio.create_task(coro1()), ...)` – излишний вариант, достаточно просто `asyncio.gather(coro1(), coro2(), ...)`.

Для наглядности, вот как можно переписать предыдущий пример через `gather` вместо ручного создания задач:
```python
res_a, res_b = await asyncio.gather(coro1(), coro2())
```
Этот код делает то же самое, что и пример с двумя `create_task` выше, но короче. Однако `create_task` дает вам возможность управлять задачами по отдельности.

## 5. Обработка результатов асинхронных операций

Когда несколько асинхронных задач выполняются параллельно, важно уметь получить их результаты. Мы уже рассмотрели один способ – дождаться всех сразу через `await asyncio.gather(...)` и получить результаты в виде списка. Но что если мы хотим обрабатывать результаты по мере готовности каждой задачи, или управлять задачами индивидуально? Рассмотрим разные подходи и в частности функцию `asyncio.as_completed`.

**Сбор результатов через `gather`:** Как уже было сказано, `gather` возвращает результаты задач в исходном порядке. Это удобно, когда порядок известен и важен. Например, если мы запускаем параллельно несколько запросов к разным URL и потом хотим сопоставить результаты с этими URL, `gather` сохраняет соответствие – результат первого awaitable будет первым элементом и т.д. Недостаток `gather` – мы получим результаты только когда **все** задачи завершатся. Если одна задача занимает гораздо больше времени, то мы будем ждать именно её, даже если другие уже давно готовы.

**Обработка по мере готовности – `asyncio.as_completed`:** Эта функция предоставляет итератор, с помощью которого можно получать завершившиеся задачи одна за другой, **в том порядке, в котором они заканчиваются**. Вы передаете список awaitable-объектов (корутин или задач) в `asyncio.as_completed(awaitables)`. Он возвращает итератор, по которому можно итерироваться в асинхронном контексте. Например:

```python
tasks = [asyncio.create_task(coro(n)) for n in range(5)]
for completed_task in asyncio.as_completed(tasks):
    result = await completed_task
    print(f"Результат получен: {result}")
```

Здесь мы сразу создали список задач `tasks`. Затем итерируемся по `asyncio.as_completed(tasks)`. Каждый `completed_task` в цикле становится доступным **как только соответствующая корутина завершилась** (не ждем остальные). Мы `await completed_task` чтобы получить результат этой конкретной задачи и, например, печатаем его или обрабатываем. Таким образом, длиннозавершающиеся задачи не задерживают обработку результатов коротких.

Такой подход полезен, например, когда вы запускаете 10 загрузок файлов, и хотите обрабатывать каждый файл сразу после скачивания (например, сохранять на диск, начинать парсить и т.д.), не ожидая, пока скачаются все остальные.

**Пример (из Part02/create_task_03.py):**  
Допустим, у нас есть корутина `fetch_page(url)` которая возвращает содержимое веб-страницы. Мы хотим одновременно загрузить несколько страниц и обработать каждую сразу после получения:

```python
import asyncio
import aiohttp

async def fetch_page(session, url):
    async with session.get(url) as resp:
        data = await resp.text()
        return url, len(data)  # вернем URL и размер данных как результат

async def main():
    urls = ["https://site1.com", "https://site2.com", "https://site3.com"]
    async with aiohttp.ClientSession() as session:
        tasks = [asyncio.create_task(fetch_page(session, url)) for url in urls]
        for task in asyncio.as_completed(tasks):
            url, size = await task
            print(f"Страница {url} загружена, размер данных: {size} байт")

asyncio.run(main())
```

Здесь задачи будут выполняться параллельно. Как только любая страница загрузилась, мы сразу получаем результат и печатаем сообщение. В итоге сообщения о загрузке страниц могут выйти в порядке 2,1,3 например – в зависимости от того, чей ответ пришел быстрее. Нам не нужно ждать самых медленных.

**Итоги:**  
- Если нужен весь набор результатов сразу и порядок важен – подойдёт `gather`.  
- Если хотим реагировать на каждое завершение задачи индивидуально – используем `as_completed`.  
- Ещё вариант: можно вручную `await`-ить каждую задачу по очереди, но тогда это ничем не отличается от последовательного выполнения (если не запускать их заранее). Чтобы задачи действительно выполнялись параллельно, их либо запускают через `create_task` (как выше), либо используют `gather`/`wait` для одновременного запуска.

Для полноты: есть также `asyncio.wait` – более низкоуровневая функция, которая может возвращать две группы задач (завершённые и незавершённые), но для большинства случаев новичкам достаточно знать про `gather` и `as_completed`.

## 6. Работа с асинхронными запросами

Один из самых популярных случаев использования асинхронности – это выполнение сетевых запросов (HTTP) в больших количествах. Библиотека `aiohttp` позволяет делать HTTP-запросы асинхронно, что идеально подходит для сценариев, когда нужно параллельно получить данные с разных ресурсов. Рассмотрим сравнение синхронного и асинхронного подхода на примере, взятом из `Part02/requests_sync.py` и `Part02/requests_async.py`. Предположим, нам нужно последовательно получить данные по нескольким URL.

**Синхронные запросы (requests_sync.py):**  
С помощью библиотеки `requests` (которая работает синхронно) код будет выглядеть примерно так:

```python
import requests
import time

urls = [
    "https://api.github.com",
    "https://httpbin.org/delay/2",   # этот URL имитирует задержку 2 секунды
    "https://httpbin.org/delay/3"
]

start = time.time()
for url in urls:
    resp = requests.get(url)
    print(f"{url} -> {resp.status_code}")
end = time.time()
print(f"Время выполнения: {end - start:.2f} секунд")
```

Здесь мы выполняем `requests.get` для каждого URL последовательно. Если первый запрос занял 0.5 сек, второй 2 сек, третий 3 сек, то общее время будет ~5.5 сек (сумма всех задержек), потому что каждый следующий запрос ждет окончания предыдущего. Вывод может быть, например:

```
https://api.github.com -> 200  
https://httpbin.org/delay/2 -> 200  
https://httpbin.org/delay/3 -> 200  
Время выполнения: 5.55 секунд
```

Обращаем внимание: время ~5.5 с соответствует сумме задержек (2+3 сек, плюс немного на первый).

**Асинхронные запросы (requests_async.py с aiohttp):**  
Теперь перепишем эту задачу используя `aiohttp` и `asyncio`, чтобы выполнять запросы параллельно:

```python
import aiohttp
import asyncio
import time

urls = [
    "https://api.github.com",
    "https://httpbin.org/delay/2",
    "https://httpbin.org/delay/3"
]

async def fetch(session, url):
    async with session.get(url) as resp:
        # получим статус, не читаем весь ответ для простоты
        status = resp.status
        print(f"{url} -> {status}")
        return status

async def main():
    start = time.time()
    async with aiohttp.ClientSession() as session:
        # запускаем задачи на фоновое выполнение для каждого URL
        tasks = [asyncio.create_task(fetch(session, url)) for url in urls]
        # дожидаемся завершения всех задач (они выполняются параллельно)
        await asyncio.gather(*tasks)
    end = time.time()
    print(f"Время выполнения: {end - start:.2f} секунд")

asyncio.run(main())
```

Объяснение коду:
- Создаем единый HTTP-сесссион `aiohttp.ClientSession()`, его используем для всех запросов (это рекомендуется для эффективности).
- Функция `fetch` делает асинхронный GET запрос и возвращает HTTP-статус.
- В `main()` мы запускаем сразу все запросы: `[asyncio.create_task(fetch(session, url)) for url in urls]` создаёт список задач (по одной на каждый URL) и сразу начинает их выполнение.
- `await asyncio.gather(*tasks)` ждёт, пока все запросы завершатся. Параллельно они могут выполняться: пока один ждёт ответ 3 секунды, другие тоже ждут свои ответы.
- Общее время выполнения измеряется аналогично.

Ожидаемый вывод асинхронной версии:
```
https://api.github.com -> 200  
https://httpbin.org/delay/2 -> 200  
https://httpbin.org/delay/3 -> 200  
Время выполнения: 3.05 секунд
```

Мы видим, что все статусы могут напечататься **почти одновременно**, но порядок может быть разный – например, даже если мы запустили в порядке [GitHub, delay/2, delay/3], фактически GitHub мог ответить первым (самый быстрый), затем (или параллельно) пришел ответ с задержкой 2, потом с задержкой 3. Главное – общее время ~3 секунды, что примерно равно максимальной задержке среди запросов, а не сумме. Таким образом, асинхронный подход позволил существенно ускорить выполнение программы, когда нужно сделать несколько запросов: вместо ~5.5 секунд мы уложились ~в 3.

**Вывод:** Асинхронные запросы особенно выгодны, когда у нас много сетевых операций. Библиотека `aiohttp` работает в связке с `asyncio`, позволяя запускать десятки и сотни запросов конкурентно. В то же время, синхронный код (например, на `requests`) для такого же числа запросов занял бы значительно больше времени, так как каждый запрос блокирует поток на время ожидания ответа.

## 7. Отмена задач и их статус

В асинхронном коде иногда требуется отменить задачу, которая больше не нужна (например, истёк таймаут ожидания, или пользователь прервал операцию). Также полезно уметь проверять, выполнена ли задача, получила ли она результат, или была отменена/упала с ошибкой. Рассмотрим, как отменять задачи и отслеживать их состояние, опираясь на примеры `Part02/task_cancelled.py` и `Part02/task_done.py`.

**Отмена (Cancellation) задач:**  
Объект задачи (`asyncio.Task`), полученный например через `asyncio.create_task` или внутри `gather`, имеет метод `.cancel()`. Вызвав `task.cancel()`, мы *запрашиваем* отмену задачи. Что происходит:
- Если задача ещё не завершилась, в её выполнение будет внесено *исключение* `asyncio.CancelledError` в ближайшей точке переключения (то есть там, где она потенциально могла бы приостановиться: на `await` или сразу, если ещё не стартовала).
- Задача может обработать это исключение внутри (через `try/except`). Если она его не перехватывает, то для внешнего кода задача считается отменённой.

Пример отмены задачи:
```python
import asyncio

async def long_task():
    try:
        print("Начали долгую задачу")
        await asyncio.sleep(5)  # долгая операция
        print("Задача завершилась нормально")
    except asyncio.CancelledError:
        print("Задачу отменили до завершения")
        raise  # пробрасываем дальше, чтобы внешне задача считалась отмененной

async def main():
    task = asyncio.create_task(long_task())
    # подождем немного и отменим
    await asyncio.sleep(1)
    task.cancel()  # запрос на отмену
    try:
        await task  # ожидаем, чтобы обработать отмену
    except asyncio.CancelledError:
        print("Отмена подтверждена: задача действительно отменена.")

asyncio.run(main())
```

Здесь мы запускаем `long_task`, ждём 1 секунду и вызываем `task.cancel()`. Так как `long_task` в этот момент находится в `await asyncio.sleep(5)`, она примет сигнал отмены и выйдет из `sleep` с исключением `CancelledError`. Мы предусмотрели обработку отмены внутри `long_task` (напечатаем сообщение и `raise` – повторно бросим исключение, чтобы внешняя среда тоже знала, что задача не выполнилась). В `main()` при `await task` это исключение всплывёт, и мы его ловим, подтверждая отмену. Вывод будет примерно:
```
Начали долгую задачу  
Задачу отменили до завершения  
Отмена подтверждена: задача действительно отменена.
```

Важно: просто вызова `task.cancel()` **недостаточно**, чтобы задача мгновенно остановилась. Отмена происходит кооперативно. Задача сможет завершиться, когда дойдёт до точки ожидания или следующего цикла событий. Если задача в текущий момент выполняет чисто CPU-операцию и не делает проверок на отмену, отмена задержится до ближайшего `await` (или пока задача не вернёт управление циклу). Поэтому, если пишете длительные корутины, которые могут понадобиться для отмены, хорошо периодически вставлять `await asyncio.sleep(0)` или разделять их на подзадачи.

**Проверка состояния задач:** Объект `Task` предоставляет методы и свойства, позволяющие узнать его статус:
- `task.done()` – возвращает `True`, если задача уже завершена (независимо, успешно или с ошибкой/отменой). Соответственно `False`, если ещё выполняется.
- `task.cancelled()` – возвращает `True`, если задача была отменена (и уже завершена именно по отмене). Если задача ещё выполняется или завершилась нормально/с другой ошибкой, вернёт `False`.
- `task.result()` – если задача успешно завершилась, вернёт её результат. Если ещё не завершилась – бросит ошибку. Если завершилась с исключением – бросит это исключение. Если была отменена – бросит `CancelledError`. Часто `task.result()` вызывают после проверки `done()` или внутри `done_callback`.
- Также есть `task.exception()` – аналогично, возвращает исключение, с которым упала задача (или `None`, если завершилась успешно или ещё работает).

Пример (task_done.py) иллюстрирует проверки:
```python
import asyncio

async def quick_task():
    await asyncio.sleep(0.1)
    return 42

async def main():
    task = asyncio.create_task(quick_task())
    print(f"Статус сразу после запуска: done={task.done()}")
    result = await task
    print(f"Статус после завершения: done={task.done()}")
    print(f"Результат задачи: {result}")

asyncio.run(main())
```
Вывод:
```
Статус сразу после запуска: done=False  
Статус после завершения: done=True  
Результат задачи: 42
```
Сразу после запуска `task.done()` False, потому что задача ещё работает. После `await task` она гарантированно завершена, `done()` True. Мы получили результат 42.

Если бы мы отменили задачу:
```python
task = asyncio.create_task(quick_task())
task.cancel()
await task  # поймаем CancelledError
print(task.cancelled())  # True, задача отменена
```
Здесь `task.cancelled()` вернёт True, указывая, что задача не просто завершена, а именно была отменена.

**Отмена групп задач:** Если вы запускаете много задач (например, через `gather`), и хотите отменить все, можно пробежаться и вызвать `.cancel()` на каждой или на самом `gather` (тогда он отменит внутренние). Например:
```python
tasks = [asyncio.create_task(coro()) for _ in range(5)]
# ... позже
for t in tasks:
    t.cancel()
```
И потом желательно выполнить `await asyncio.gather(*tasks, return_exceptions=True)` чтобы подавить возможные исключения отмены, либо по отдельности ловить.

**Итог:** `task.cancel()` – способ отменить задачу, `task.done()` – проверить, закончилась ли она, и `task.cancelled()` – узнать, была ли она отменена. Эти механизмы помогают управлять жизненным циклом задач, особенно в долгоживущих программах (например, серверах), где может потребоваться остановить фоновые операции аккуратно.

---

В заключение, асинхронность в Python позволяет писать эффективный код для большого числа конкурентных операций ввода-вывода. Корутины и ключевые слова `async/await` дают выразительный синтаксис, похожий на обычный последовательный код, но с возможностью выполнять многие задачи параллельно (по времени). Понимание того, как запускать, ждать и отменять такие задачи, позволит вам создавать быстрые и отзывчивые приложения. Главное – не бояться экспериментировать с примерами и постепенно почувствовать работу цикла событий. Используя аналогии вроде официанта или умного повара, можно интуитивно представить себе работу асинхронного кода: не тратить время впустую в ожидании, а делать что-то еще полезное.